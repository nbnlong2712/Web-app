# Story 1.4: Implement Basic Chat-style Search Input

## Status
Draft

## Story
**As a** visitor,
**I want** a chat-style input on the home page to describe my need in natural language,
**so that** the system can quickly suggest suitable tools.

## Acceptance Criteria
1. Home page has a chat-style input component with glass styling
2. Input has proper placeholder text and focus behavior
3. Submit button and Enter key submission work correctly
4. Basic intent parsing function is implemented
5. Search results area is prepared for displaying tools
6. Loading states and empty states are implemented

## Tasks / Subtasks
- [ ] Create chat input component
  - [ ] Design chat input with glass styling matching Neo-Glassmorphism theme
  - [ ] Implement placeholder and focus behavior
  - [ ] Add Send button and Enter key submission
  - [ ] Ensure proper accessibility attributes (labels, roles)
- [ ] Implement intent parsing
  - [ ] Create `lib/intent/parse.ts` with basic intent parsing function
  - [ ] Implement parsing for basic filters (pricing, platform, language)
  - [ ] Add synonym dictionary for tags in `lib/intent/synonyms.ts`
  - [ ] Unit test the parser with sample inputs
- [ ] Set up search results area
  - [ ] Create SSR results region with `aria-live="polite"`
  - [ ] Prepare structure for displaying tool cards
  - [ ] Implement loading states with skeleton components
  - [ ] Implement empty states with suggestions
- [ ] Integrate search functionality
  - [ ] Connect input to intent parser
  - [ ] Prepare for database queries (will be implemented in next story)
  - [ ] Test end-to-end flow with mock data
- [ ] Verify accessibility
  - [ ] Test keyboard navigation
  - [ ] Verify screen reader announcements
  - [ ] Check focus management

## Dev Notes
### Home Page Requirements
- `app/page.tsx` (Home): chat input, suggestion chips, SSR results region (aria-live="polite"), empty/loading states (skeleton shimmer >100ms)

[Source: docs/architecture/5-front-end-application-structure.md]

### Search & Intent Mapping
Non-LLM parser converts natural language to filters; SSR query combines filters + FTS/trigram similarity and returns ≤ 24 results sorted by specificity and similarity.

Parser (TypeScript, pseudocode):
```ts
export function parseIntent(input: string) {
  const text = normalize(input); // lowercase, strip punctuation, remove diacritics (VI)
  const out: any = { tags: [] };
  if (/(mien phi|free|0d|0đ)/.test(text)) out.pricing = 'free';
  else if (/freemium/.test(text)) out.pricing = 'freemium';
  else if (/(tra phi|paid|\$|usd|vnd|đ)/.test(text)) out.pricing = 'paid';
  if (/(khong can dang ky|no signup|khong can account)/.test(text)) out.no_signup = true;
  if (/\bapi\b/.test(text)) out.platform = 'api';
  if (/(web|trinh duyet)/.test(text)) out.platform = 'web';
  if (/(desktop|windows|macos|mac)/.test(text)) out.platform = 'desktop';
  if (/(tieng viet|vietnamese|\bvi\b)/.test(text)) out.language = ['vi'];
  if (/(english|\ben\b)/.test(text)) out.language = [...(out.language||[]), 'en'];
  // primary_tag & tag synonyms resolved from a static dictionary
  for (const [tag, syns] of Object.entries(SYN)) {
    if (syns.some(s => text.includes(s))) { out.primary_tag = tag; break; }
  }
  for (const [t, syns] of Object.entries(FLAT_TAGS)) {
    if (syns.some(s => text.includes(s))) out.tags.push(t);
  }
  return out;
}
```

[Source: docs/architecture/4-search-intent-mapping.md]

### Components
- `SearchBox`: Chat-style input with glass styling
- Need to create skeleton loading components

[Source: docs/architecture/5-front-end-application-structure.md#components]

### Styling and A11y
- **Glass UI**: Respect theme tokens (blur, borders, subtle shadows)
- **A11y**: Visible focus states, semantic HTML, proper ARIA; SSR results region uses `aria-live="polite"`

[Source: docs/architecture/coding_standards.md#7]

### Performance Budgets
- Home SSR TTFB ≤ 500ms (P50)
- Use skeleton loading for >100ms wait times

[Source: docs/architecture/coding_standards.md#9]

### Example Implementation
**`app/page.tsx`** (SSR search entry)
```tsx
import { parseIntent } from '@/lib/intent/parse'
export default async function Home({ searchParams }: { searchParams: { q?: string } }) {
  const q = (searchParams?.q ?? '').slice(0, 200)
  const intent = parseIntent(q)
  // TODO: call DB query once RPC is ready
  return (<main>/* input, results grid, a11y live region */</main>)
}
```

[Source: docs/architecture/source-tree.md#2]

## Testing
### Test file location
- Tests should be placed in `tests/unit/` directory
- Test file: `tests/unit/intent-parser.test.ts`

### Test standards
- Unit test the intent parser with various input scenarios
- Test both English and Vietnamese inputs
- Verify correct parsing of pricing, platform, and language filters

### Testing frameworks and patterns to use
- Vitest for unit testing
- Test the `parseIntent` function with 20 representative phrases (EN/VI) from the test cases
- Mock external dependencies
- Verify functionality with explicit assertions

[Source: docs/architecture/4-search-intent-mapping.md#test-cases]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
|      |         |             |        |

## Dev Agent Record
### Agent Model Used
TBD

### Debug Log References
TBD

### Completion Notes List
TBD

### File List
TBD

## QA Results
TBD